Recently, our team has been developing a full-link log solution on Flutter that can monitor user access page paths and user click behavior. This requires Flutter to support non-intrusive AOP functionality, which can replace function implementations and add tracking code at compile or runtime. However, Flutter prohibits reflection for reasons such as package size and robustness.After research, we found that we can use the AspectD open-source framework to implement AOP based on modifying the .dill output during compilation.AspectD is an open-source AOP library for Flutter, and its GitHub address is: https://github.com/alibaba-flutter/aspectd.AspectD enables Flutter to have the ability of AOP, providing us with many ideas for doing full tracking schemes and making many ideas possible.AspectD has been discontinued for a while and has not yet been adapted to Flutter 2.x.x and 3.x.x versions. Therefore, based on AspectD, we created house_aspectd and adapted it to Flutter 2.5.3 and 3.0.0 versions, and more versions are also being adapted.The following steps were taken to adapt to other Flutter versions:Switch the flutter SDK to the corresponding version branch and write the support for AOP code on the current branch.Replace the Dart source code in the house_aspect/inner folder with the code of the new version.Modify the compilation process to enable it to recognize aspectd annotations and regenerate the .dill file.Use the command to regenerate the frontend_server.snapshot file.dart --deterministic --snapshot=frontend_server.dart.snapshot starter.dartcd path/to/fluttergit apply path-for-house_aspectd-package/inner/flutter_tools.patchrm bin/cache/flutter_tools.stampAfter deleting the flutter_tools.stamp file, the flutter_tools will rebuild on the next build of the Flutter project.dependencies:  house_aspectd:    path: ../path/house_aspectdAdd a file named aop_config.yaml to the root directory of the project (same level as pubspec.yaml), with the following content:flutter_tools_hook:  - project_name: 'house_aspectd'Flutter_tools will check this file to determine whether house_aspectd is enabled.For example, hook_example.dart (used to implement aop)import 'package:house_aspectd/aspectd.dart';@Aspect()@pragma("vm:entry-point")class CallDemo {  @pragma("vm:entry-point")  CallDemo();//实例方法 @Call("package:example/main.dart", "_MyHomePageState",     "-_incrementCounter") @pragma("vm:entry-point") void _incrementCounter(PointCut pointcut) {   print('call instance method2!');   pointcut.proceed(); }}In main.dart, reference this file to avoid being optimized by the compiler. When we run the project again, when the _incrementCounter method in _MyHomePageState is triggered, it will call the _incrementCounter method added in hook_example.Use the @Aspect() annotation to mark a class so that aspectd knows that the class contains AspectD’s annotation (indicating aspect-oriented programming) information.In AOT compilation, if the code is not referenced, it will be discarded, and the AOP code will not be referenced. This method is used to tell the compiler not to discard the code.@Call will modify the calling location and will not modify the internals of the original method.@Execute will modify the internals of the original method.In the full-chain log collection of real estate Flutter, user click event behavior recording and global monitoring of user page access paths are achieved through house_aspectd. Specifically:User behavior recording refers to the click events of the user, which can be intercepted uniformly by hooking all methods under a package. The code is as follows:// instance method    @Call("package:demo_project_flutter\\/.+\\.dart", ".*", "-.*", isRegex: true)    @pragma("vm:entry-point")    dynamic _instanceMethod(PointCut pointcut) {        var timeStamp = DateTime.now().millisecondsSinceEpoch;      log('[aspectd]: instanceMethod call start -----------------------' + 'currentTimeStamp is + ' + timeStamp.toString());        log( 'target is ' + pointcut.target.toString() + '     ' + 'function is ' +  pointcut.function);      var ret = pointcut.proceed();        var diff = DateTime.now().millisecondsSinceEpoch - timeStamp;      log('[aspectd]: instanceMethod call end -----------------------' + 'currentTimeStamp is + ' + DateTime.now().millisecondsSinceEpoch.toString() + '    duration is ' + diff.toString() + 'ms' + '\n\n');      return ret;    }pointcut.proceed() is used to call the original method, and timestamps can be obtained before and after the call to calculate the method execution time.After obtaining the logs, they can be written to the local storage through a channel. When necessary, they can be uploaded to the server.For page access recording, as the current real estate project all use the `HouseFlutter.instance.open` method in `house_flutter_base` to navigate, the user page access record can be obtained by hooking the above method. The code is as follows:// house_flutter_base route method  @Call("package:flutter_house_base/src/house/house_flutter.dart", "HouseFlutter", "-open")  @pragma("vm:entry-point")  dynamic _openMethod(PointCut pointcut) {    var timeStamp = DateTime.now().millisecondsSinceEpoch;    log('[aspectd]: _openMethod call start -----------------------' + 'currentTimeStamp is + ' + timeStamp.toString());    log('routeUrl is ' + pointcut.positionalParams[0].toString() + '   routeParams is ' + pointcut.namedParams.toString());    var ret = pointcut.proceed();    var diff = DateTime.now().millisecondsSinceEpoch - timeStamp;    log('[aspectd]: _openMethod call end -----------------------' + 'currentTimeStamp is + ' + DateTime.now().millisecondsSinceEpoch.toString() + '    duration is ' + diff.toString() + 'ms' + '\n\n');    return ret;  }Here’s an example of the effect:AspectD completes code instrumentation based on annotations by modifying the generated .dill artifacts during the compilation phase. To understand its principles, we need to have some knowledge about the compilation process of Flutter.As shown in the above diagram, when compiling Flutter, `flutter_tools` first calls the frontend_server of the front-end compiler, which converts Dart code into an AST and generates the `app.dill` file. Then, in debug mode, `app.dill` is converted to `kernel_blob.bin`, and in release mode, `app.dill` is converted to `framework` or `so`.The AOP of `house_aspectd` is achieved by modifying the compilation process of the front-end compiler. This is to modify the `app.dill` file. Therefore, we mainly focus on the step of `Dart -> app.dill` to understand the modification process.To use our own `frontend_server` in the compilation process of Flutter, and to modify `frontend_server` to generate a new `app.dill`, we need to address two issues:Issue 1: Modifying `flutter_tools` requires modifying the code in the Flutter SDK and regenerating `flutter_tools.snapshot`. Since we cannot modify the code of the official Flutter SDK, we need to fork our own Flutter repository and generate a patch through git patch, and then modify the local Flutter SDK code by using git apply.Issue 2: Modify the `frontend_server` code and regenerate `frontend_server.dart.snapshot`. Replace the one included in the SDK with the newly generated snapshot.// frontend_server路径

/opt/fvm/versions/2.5.3/bin/cache/dart-sdk/bin/snapshots/frontend_server.dart.snapshot// Frontend_server path/opt/fvm/versions/2.5.3/bin/cache/dart-sdk/bin/snapshots/frontend_server.dart.snapshot// Flutter_tools path/opt/fvm/versions/2.5.3/bin/cache/flutter_tools.snapshotWhat do git patch and git apply do?git patch is used to modify the compilation process of flutter_tools to replace frontend_server.snapshot and modify .dill files according to the aspectd annotation during compilation.Here are the steps to make modifications:1. Fork a copy of the flutter sdk to your own repository.

2. Modify the code under the flutter_tools folder in your own repository to add support for replacing frontend_server.snapshot and other logic.

3. Use git format-patch to generate .patch patches.

4. Finally, cd to the flutter path installed on your computer and execute git apply xx/xx/xx.patch.After completing the above steps, we can view the modifications to the local flutter sdk. The specific file modifications are shown in the figure below:Let’s take a look at the added logic:await AspectdHook.enableAspectd();If it exists, check if frontend_server.snapshop has been replaced.If it has been replaced, enter the compilation process directly. If not, replace it and then enter the compilation process.3. This way, frontend_server can be replaced during the build process to implement custom logic.house_aspectd mainly modifies two processes of flutter:flutter_tools (modify to use our frontend_server.dart.snapshot during compilation)frontend_server (modify the compilation process to modify .dill files according to asptctd annotations)Our debugging mainly focuses on frontend_server to see how it modifies .dill files during compilation. For specifics on how to debug, please refer to another document. Here, we will learn how dill files are modified through debugging.void main(ListFuture starter(    List args, {      frontend.CompilerInterface compiler,      Stream> input,      StringSink output,    }) async {  ...  //Parse arguments.  ArgResults options = frontend.argParser.parse(args);  //Create an instance of the frontend compiler.  compiler ??= _FlutterFrontendCompiler(output,      transformer: ToStringTransformer(transformer, deleteToStringPackageUris),      useDebuggerModuleNames: options['debugger-module-names'] as bool,      emitDebugMetadata: options['experimental-emit-debug-metadata'] as bool,      unsafePackageSerialization:          options['unsafe-package-serialization'] as bool,      aopTransform: options['aop'].toString() == '1' ? true : false);    if (options.rest.isNotEmpty) {    //Parse the remaining command line arguments.    return await compiler.compile(options.rest[0], options) ? 0 : 254;  }  ...}Replaces the frontend compiler with _FlutterFrontendCompiler provided by AspectD, and performs the compilation operation.The _FlutterFrontendCompiler provided by aspectd mainly overrides the methods of the frontend.CompilerInterface interface and implements the compiler method as shown below:@override  FutureFrom the source code, we can see that it adds the aspectdAopTransformer to participate in the compilation, i.e., it introduces our core member `aspectdAopTransformer`, which is an instance of type `AopWrapperTransformer()` and comes from `aop_transformer.dart`.From the source code, we can see that it adds the aspectdAopTransformer to participate in the compilation, i.e., it introduces our core member aspectdAopTransformer，which is an instance of type AopWrapperTransformer() and comes from aop_transformer.dartThis class is a subclass of FlutterProgramTransformer and mainly overrides the transform method:@override  void transform(Component program) {    for (Library library in program.libraries) {      componentLibraryMap.putIfAbsent(          library.importUri.toString(), () => library);    }    program.libraries.forEach(_checkIfCompleteLibraryReference);    final ListThe function performed by _resolveAopProcedures(libraries) is to traverse each class from libraries, capture the annotation information on the class with aspectD annotations, and then instantiate AopItemInfo and add it to aopItemInfoList.for (AopItemInfo aopItemInfo in aopItemInfoList) {  if (aopItemInfo.mode == AopMode.Call) {    callInfoList.add(aopItemInfo);  } else if (aopItemInfo.mode == AopMode.Execute) {    executeInfoList.add(aopItemInfo);  } else if (aopItemInfo.mode == AopMode.Inject) {    injectInfoList.add(aopItemInfo);  } else if (aopItemInfo.mode == AopMode.Add) {    addInfoList.add(aopItemInfo);  }}Annotations are divided into several categories, and here we focus on how to transform the code of the AopMode.Call type. Use AopCallImplTransformer.This class inherits from Transformer, overrides the relevant methods, and mainly looks at visitInstanceInvocation here:@override  InstanceInvocation visitInstanceInvocation(      InstanceInvocation instanceInvocation) {    instanceInvocation.transformChildren(this);    final Node node = instanceInvocation.interfaceTargetReference?.node;    String importUri, clsName, methodName;    if (node is Procedure || node == null) {      ...      final AopItemInfo aopItemInfo = _filterAopItemInfo(          _aopItemInfoList, importUri, clsName, methodName, false);            return transformInstanceMethodInvocation(            instanceInvocation, aopItemInfo);    }    return instanceInvocation;  }The main logic is to obtain the basic importUri, clsName, and methodName through the methodInvocation, then filter out the corresponding aopItemInfo that meets the conditions through _filterAopItemInfo, and finally call transformInstanceMethodInvocation. This method, as the name suggests, inserts aspect into instance methods of a class.The main logic of this method is to extract the importUri, clsName, and methodName from the methodInvocation object, and then filter the aopItemInfo list with _filterAopItemInfo method to find the matching aspects. Finally, the transformInstanceMethodInvocation method is called to insert the aspect code into the original class instance method.In this method, a mockedInvocation object is created, and the createPointcutStubProcedure method is called to create a new procedure that records the aspect information and original code.bool insertInstanceMethod4Pointcut() {        //Add library dependency    //Add new Procedure    ...    final InstanceInvocation mockedInvocation = InstanceInvocation(        InstanceAccessKind.Instance,        AopUtils.concatArguments4PointcutStubCall(            originalProcedure, aopItemInfo),        interfaceTarget: originalProcedure,        functionType: originalInvocation.functionType);    ...    createPointcutStubProcedure(        aopItemInfo,        stubKey,        pointCutClass,        AopUtils.createProcedureBodyWithExpression(mockedInvocation,            !(originalProcedure.function.returnType is VoidType)),        shouldReturn);    return true;  }Finally, the `AopUtils.insertProceedBranch` method is called to insert the aspect code into the original code.//Will create stub and insert call branch in proceed.  void createPointcutStubProcedure(AopItemInfo aopItemInfo, String stubKey,      Class pointCutClass, Statement bodyStatements, bool shouldReturn) {    final Procedure procedure = AopUtils.createStubProcedure(        Name(stubKey, AopUtils.pointCutProceedProcedure.name.library),        aopItemInfo,        AopUtils.pointCutProceedProcedure,        bodyStatements,        shouldReturn);    pointCutClass.procedures.add(procedure);    if(procedure.isStatic) {      procedure.parent = pointCutClass.parent;    } else {      procedure.parent = pointCutClass;    }    AopUtils.insertProceedBranch(pointCutClass, procedure, shouldReturn);  }After this process, the `writeDillFill` method is called to overwrite the original `.dill` file.The .dill file is an intermediate file generated by the dart compilation process when flutter_tools calls frontend_server to convert dart code. We can find the compiled .dill file in the build directory of our project. By inspecting the .dill file, we can verify if our hook code is effective.The .dill file itself is not readable. However, we can use the dump_kernel.dart tool in the dart vm to convert the .dill file into a readable format.To do so, follow these steps:First, download the corresponding Dart SDK for Flutter. After downloading it, find the revision of the SDK that matches your Flutter version. You can find this in the path_to_flutter/bin/cache/dart-sdk/revision file.cd to the downloaded Dart SDK path, and execute git checkout with the revision you found in step 1.path_to_flutter/bin/cache/dart-sdk/bin/dart  path_to_dart/pkg/vm/bin/dump_kernel.dart path_to_your_project/.dart_tool/flutter_build/***/app.dill output_path/out.dill.txt4. Open the output.dill.txt file, find the hook method, and confirm whether it has been replaced.Comparison of dill.txt file before and after hooking. The dill file before hooking the _incrementCounter method looks like this:And the dill file after hooking the `_incrementCounter` method looks like this:By comparison, it can be seen that the call to `_incrementCounter` has been modified. At this point, when we trigger the `_incrementCounter` method, it will go into the hook method.The Fair team comes from the open source group of 58.com and has designed and implemented the core functions of Fair, a full-process solution for Flutter dynamic development. They are responsible for controlling the functional planning, feature introduction, and implementation progress of the module. When the community cannot reach a consensus, they make the final decision.If you are interested in Flutter & Fair related technologies,you are welcome to join us to build Fair and the Flutter ecosystem together. And feel free to give us a star~