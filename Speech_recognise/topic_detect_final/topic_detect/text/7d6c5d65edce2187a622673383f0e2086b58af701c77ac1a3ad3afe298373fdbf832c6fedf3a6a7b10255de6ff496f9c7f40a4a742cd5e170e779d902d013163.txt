These facts made web development one of my favorite fieldsPhoto by Emile Perron on Unsplash, edited with CanvaI started programming when I was thirteen years old with Visual Studio 6.0 IDE. A few months later, I printed hello world with Java. At that time, I didn’t have an internet connection, so I used physical books, tutorial CDs, and inbuilt documentation to learn programming syntax and APIs. I started browsing the internet with Microsoft Internet Explorer 6.0. Then, I started learning web design by creating web pages with Notepad. I created web pages with Adobe Dreamweaver too. Next, I started building my own HTML designing software with the Microsoft DHTML editing component OCX and Visual Basic by copying my favorite features from Dreamweaver UI. I continued learning web design and experimenting with HTML, JavaScript, and CSS for several years. At that time, most small-scale business entities tried to create websites for themselves via freelancers — so I planned to become a freelance web developer about ten years ago and started building websites for businesses. A few months later, I started building web apps with PHP, MySQL, and JQuery and started designing websites with WordPress. During my past PHP era, I used several code editors on Windows platforms: Notepad++, Sublime Text, Dreamweaver, and Intellij WebStorm.I ended my JQuery-based frontend development journey by learning React and Angular around 2017. Then, I started using Node.js and NoSQL database systems for developing backends with the RESTful concept. I also switched my workstation’s operating system to GNU/Linux and started mastering DevOps during this period. During my 10-year-old web development journey, I learned the following lessons that still make my web development activities so interesting!

1. Learning Web Architecture Is so Important as Learning TechnologiesWe have to choose a suitable web architecture before selecting a technology stack for web apps. Web architecture typically describes the structure of your web application components. Earlier, developers created a single package for a web app and deployed it into a single bare-metal server computer by following the traditional monolithic pattern. Nowadays, web developers use the microservices architectural concept by separating the web app into internal services and using external managed services (i.e., email-sending and database services). Modern developers also use the serverless architecture by using managed cloud computing services. Tech companies typically hire developers based on technologies they use — not based on web architecture. Newly hired developers gradually become familiar with their company’s web app architecture when they contribute more. Even though tech companies use various technology stacks and system design practices, they internally use generic, theoretical architectural components, such as load balancers, microservices, API gateways, queues, CDNs, etc. So, once you master the theoretical aspect of web architecture, becoming a senior developer in any web app team is a piece of cake once you become productive in working with technologies and domain knowledge.The following story explains generic web elements that every web developer should know:

In software development, dependency is a common term for describing a component you usually take from other parties — rather than building yourself. For example, you may use React as a dependency library to create component-based web frontends, or Express.js to develop your web backends. Some dependency components become smaller, easy-replaceable elements in our web projects. Sometimes, our web project will highly depend on some dependency components. Imagine you use a backend framework to build a web app that tightly couples framework features. What if the framework team releases a major version with a new API? Then you either have to migrate to the latest version or live in a legacy world that modern developers don’t like to look at. What if one of your dependency libraries gets deprecated or struggles with a critical, long-term, unsolved security vulnerability? What if it’s hard to solve a new requirement with your current dependency library, and an alternative library offers an inbuilt feature to solve your requirement?I typically invest time in researching dependencies before selecting one by carefully evaluating features, API design, documentation, developer support, popularity, and source repository maintenance. I usually create a table in a Google Doc for dependency comparison and select one based on the pros and cons (with workarounds for them). If possible, making a dependency easy-replaceable is a wise design pattern, i.e., creating a wrapper or utility module.

3. Monolithic Design Is Not Bad as You ThinkNowadays, most developers choose the modern microservice design for building web-based software systems with advanced DevOps practices, such as failure detection/recovery systems, alerting techniques, error-reporting modules, etc. Cloud computing platforms also offer microservice-focused services for building web systems with loosely-coupled components. Moreover, popular tech companies’ architectures and modern web development learning resources motivate others to choose microservice-based patterns. As a result, the traditional monolithic design became less popular among modern web developers. Nowadays, some web development teams choose a microservice-based architecture for building small-scale systems that don’t need much scalability. For example, some developers run multiple replicated microservices for scenarios they can solve with a single monolithic, layered RESTful instance.Microservice design is undoubtedly suitable for large-scale, performance-first, rapidly-growing web systems that have a large development team. But, microservice design may complicate your simple systems and make the getting started process hard for newcomers. On the other hand, the monolithic design promotes simplicity. The monolithic design concept is alive, and even StackOverflow uses monolithic architecture!

4. DevOps Is Mandatory to Be Competitive and ProductiveIn the past, web developers manually uploaded source files to server computers and updated database modules. When I worked with PHP projects, I released new web app versions by uploading source files with FileZilla and applying database changes via phpMyAdmin. I used to post a maintenance message to users and make each deployment during nighttime. Now, the DevOps movement changed this manual workflow and introduced an automation-first culture. Modern developers can update one live web module by (automatically) redirecting traffic to a newly replicated instance. Futuristic error-reporting systems can automatically create an issue on agile boards whenever a failure happens. Moreover, some microservices can self-heal on failures.DevOps culture helps us deploy new features faster, prevent production bugs, and fix detected bugs faster to win good customer satisfaction. Being productive and competitive in the modern software market is a dream without a better DevOps foundation.The following story explains how to improve programming skills with DevOps knowledge:How to Improve Your Programming Skills by Learning DevOpsYou don’t need DevOps skills to become a coder, but you need DevOps skills to become a programmer.

5. Creating Your Own App Template Is a Productivity SecretI developed 30 more monolithic PHP web apps for several customers during 2013–2019. They used PHP MySQL backends and JQuery/UI-based frontends. At that time, I created my own app template with app config, authentication/authorization, pre-developed pages, client-server connectivity (AJAX-based), etc. Whenever I started a new project, I started the development process productively by changing a few constants in my template to change the theme, app title/description, database connection, etc. Nowadays, most open-source boilerplates let you instantly set up a full-stack app with preferred backend/frontend technologies. But, they may offer features that we don’t need and may use different design patterns than you expect. So, creating your own app template is still a good idea even though pre-built boilerplates exist.

Users don’t see your modern, well-structured web architecture or nearly-perfect, well-maintained codebase. All they see is what you present to them via the web browser. Besides, they may evaluate your system based on productivity features (i.e., notifications) and performance. Imagine the following scenarios in a web app:Users frequently navigate into the reports section and see a particular reportUsers see the summary of the frequently visited report in a dashboard widget and can generate the full report instantly from the widgetThe second scenario undoubtedly increases user reputation for your app. Similarly, using better UI/UX principles, such as implementing a consistent color theme, minimal UI, and productivity-first design enhance product quality and helps to increase customer satisfaction.

In the past, web developers mostly used the web server’s computation power and used the web client only to render the app interface via HTML documents. The traditional MVC pattern is a good example of this concept. Web development technology gradually shifted the computation power usage from the server to the client. First, developers used the AJAX technique and made multiple network requests from the client. Next, they decoupled their apps into two modules: frontend and backend. The frontend module started using the client’s computation power for various processing activities. Nowadays, some web apps even use WebAssembly, and web workers for performing somewhat heavy tasks. Moreover, most modern apps implement client-side caching and network optimization techniques to avoid excessive backend calls. Using the client’s computation power typically improves usability and productivity factors. For example, you may implement client-side validation, searching, sorting, and calculating totals to save network bandwidth and boost app speed.On the other hand, excessive client-side computations or processing can slow down users’ computers (especially low-end machines). Spread your app’s business logic optimally between in backend and frontend. Learn how to write well-optimized code with the following tips:5 Things To Know Before You Write Optimized CodeThese facts help you to impress both hardware and programmers with optimized code